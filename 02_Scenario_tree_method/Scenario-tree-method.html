<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Scenario Tree analysis</title>
    <meta charset="utf-8" />
    <meta name="author" content="Eleftherios Meletis, Aurélien Madouasse" />
    <meta name="date" content="2022-03-23" />
    <script src="libs/header-attrs-2.11/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Scenario Tree analysis
## 09:30 - 10:00
### Eleftherios Meletis, Aurélien Madouasse
### 2022-03-23

---





class: inverse, center, middle

## Scenario tree method - Introduction

Reference method to estimate the probabilities of freedom from infection from complex surveillance systems

&gt; Answers to:

* I. If infection was present at the design prevalence, what would be the probability of the surveillance system detecting at least 1 case?
 &lt;font size="6"&gt; Surveillance sensitivity&lt;/font&gt;
* II. Given that no cases have been detected, what is the probability that true infection prevalence is lower than the design prevalence?
 &lt;font size="6&gt; Probability of freedom from infection&lt;/font&gt;

&gt; Principle: A surveillance system is represented as a tree with different components

---

## Scenario tree method - Simple Example

#### Let's see a simple quick example that will help us understand
(i) Scenario tree notation 
(ii) Scenario tree calculations

Objective: prove freedom from Bovine Viral Diarrhea virus (BVDV) in country A 

---

The following figure shows the structure of the surveillance system.

![](figs/simple_scenario_tree.png)

---

The surveillance system is split, given the herd type, to dairy and beef cattle.
We assume that design prevalence is the same for both dairy and beef cattle.

Given the herd type a different diagnostic method to detect infection is applied.
Dairy - Bulk Tank Milk
Beef - Blood  sample [e.g., serum ELISA]

---

## Scenatio tree notation

* Herd type - Risk category node
* Herd status - Infection node
* BTM test / Blood test - Detection node

&gt; 
* Risk Category node - represent factors dividing the SSC population into subsets with different probabilities of being infected
* Infection node - represent the infection status, branch probabilities derived from design prevalence [Infected - Uninfected]
* Detection node - represent the detection of infection, associated with test characteristics [Positive - Negative] 

*Branch proportions at each category node must sum to 1*

Our surveillance system has two surveillance components, that are complementary.

---

## Scenario tree calculations 

&gt; Scenario tree constraints
* All final results from the SS are consistent with country or zone freedom from infection
* Specificity of the surveillance system is 100% 

Complex Surveillance systems have more than one detection nodes

Units with a positive test outcome are retested (with a "better" method).

The process of repeated testing (sequential testing)
(I) Reduces the probability of a false-positive output in the surveillance system (Sp of SS = 1)
(II) If a true-positive unit is detected then the country's/zone's claim freedom from infection is no longer valid and the method is no longer applicable

---

# Simple Example - R code

#### Input parameters

* Design prevalence
* Test characteristics of BTM and Blood test
* Number of herds tested, per herd type



```r
# Design prevalence
p_design = 0.02

#Test characteristics
# BTM test
Se_BTM = 0.9
Sp_BTM = 1
# Blood test
Se_Blood = 0.95
Sp_Blood = 1

# Number of herds tested, per herd type
n_dairy = seq(10,400,20)
n_beef = seq(10,600,10)
```

---

### Estimate Surveillance component sensitivity

$$
SCSe = 1 - (1 - p^* *Se^unit^)
$$

$$
OverallSSe = 1 -mul_{i=1}^{n}{1 - SCSe_n}
$$


```r
CSE_dairy = 1 - (1-(p_design*Se_BTM))^n_dairy
CSE_beef = 1 - (1-(p_design*Se_Blood))^n_beef

Overall_SSE = 1 - (1-CSE_dairy)*(1-CSE_beef)
```

---
## Estimate probability of freedom from infection

$$
Pr_freedom = Pr(D^- | S^-) = Negative  Predictive  Value
$$
Using Bayes rule

$$
Pr_freedom = Pr(D^- | S^-) = \frac{Pr(S^- | D^-) Pr(D^-) )}{Pr(S^-)} = \frac{Pr(S^- | D^-) Pr(D^-) )}{Pr(S^- | D^-) Pr(D^-) + Pr(S^-|D^+)*Pr(D^+)} =
\frac{Sp_SS * (1-p^*)}{Sp_SS * (1-p^*) + (1 - Se_SS)*P^*}
$$

We assume that Sp_SS = 1 then

$$
Pr_freedom = Pr(D^- | S^-)=
\frac{(1-p^*)}{(1-p^*) + (1 - Se_SS)*P^*}
$$


```r
P_freedom = (1-p_design)/((1-p_design) + p_design*(1-Overall_SSE))
```

---

Load libraries

```r
library(epiR)
```

```
## Loading required package: survival
```

```
## Package epiR 2.0.43 is loaded
```

```
## Type help(epi.about) for summary information
```

```
## Type browseVignettes(package = 'epiR') to learn how to use epiR for applied epidemiological analyses
```

```
## 
```

---

## Simple example
Create - Plot the scenario tree



Load data


Set design prevalence


Estimate the probability of freedom from infection

```r
#rsu.pfree.rs(se.p, p.intro = 0, prior = 0.5, by.time = TRUE)
```


Change the value of design prevalence










    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16/9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
